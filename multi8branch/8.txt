Розбераемся с multi-brach pipeline (имеем различ настойки в различ версиях нашего кода )

Мульти бранч пайпы имеют отношения с scm :
обьясниния скрина 
у нас в гите есть несколько веток кода , есть ветка мастер (тут храню код) и в какой-то момент хочу добавить возможность , я создаю фичу ветку  - отчепляюсь от текущ точки на мастере , получаю колон текущ кода на мастере , и потом если всё гуд то идёт вливания обратно в мастер - Суть , может быть несколько версий кода (и все версии храняться в ветках) , теперь мы сделаем чтоб дж не уперался не в одну ветку (как я делал до этого ), а работал вцелом с репой . В резульате можем иметь разные дж файлы в разных ветках (дж можно добавть возможно новый тест ) или можно одним и тем-же дж файлом (если он не меняеться между ветками , соберать текущ версию кода которая есть в текущ ветке



-------
есть ветка мастер и есть дж файл там , теперь скажем дж чтоб работал с другим типом пайпов и потом создадим новую ветку 


создаю новый пайп - docker_buildnew (multibranch pipeline)- будет рабоать с кучей веток 
в source говорю что наша репа находиться на гите , затем указываю владельца , выбераем репу (затем идут настройки проверки нашей репы ... но нам надо добавить поверединя гита - очищать директорию перед тем как выкачивать новую версию иначе у нас будет накапливаться в директории сборки мусор , и когда я буду заново выкачивать репу у меня там могу результаты прошлос сборки оставаться - будет бардак -clear before checkout И надо обязательно удалять старые ветки prune stale remote-tracking branches - если в гите будут постоянно появляться новые ветки в гите , потом ктот их будет сливать удалять ... в дж будут этот мусор хранитсья (они будут видны иначе* - чекай ссылку на плагин)
затем указываем что использоваем дж файл (указывает путь)

Теперь если новые ветки будут содержать docker_build.jenkins , то это ветка будет определятсья в дж и этот пайп будет собераться 
*у меня нет возможности пробросить хуки он гита до дж - нам нужно будет самим переодически сканировать нашу репу удалённо на наличие веток ну и на удаление старых веток ... 
дальше указываем сколько надо хранить старые ветки если они нужны и всё 


После чего идёт сразу чекание на наличие новых веток и на нахождение в них дж файла (внешне дж выглядит по другому (книжечка)




-------
а теперь ради рофла , создадим новую ветку , и теперь вносим изминения в этой ветке (добавим пакет в докерфайл - postgresql-client  (комичу и отправляю на серв ) в результ чего будет 2 ветки , теперь создадим ещё одну ветку НО внеё удалю докербилд.дж 

и потом сразу увидем что наша ветка там где есть дж будет сразу собератсья , НО можно чекнуть лог наших реп - дж проверяет бренчи , находит 2 ветки и в первой ветке он находит екз.1  наш дж файл а во второй его нет 

вывод 
потрогали мультибранч пайпп , увидели как он работает (суть , может быть несколько веток , в каждой ветку могут быть свои настройки , дж проверяет на наличие опред. файла , если он его находит он его выполняет - тут нету смысла так как у нас один латест тег (он просто перезаписываетсья )
