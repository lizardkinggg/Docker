Сегодня продолжаем развивать наш  пайп , сделаем его более автоматиз - вопрос , как связать систему хранения кода с системой ci/cd (автоматизации) (дж , но спарведливо для любых подобных систем)


АВТОМАТИЧ ЗАПУС ПАЙПА 
Розбор скрина магия девопса (как выглядит все в идеале)
1) Розраб вносит изминения 
2) в результате чего через время получает доступ к коду *желательно чтоб в этот момент к нему прилетали результаты тестов (сборок , деплоев ... )

Как это делать , будем сегодня розберать 

Что скрываеться за волшебником (обьяснения магика джонсона) 
Есть куча вариков как это реализовать , но расмотрим самый основной 


1)розраб выполняет пуш своего коммита (отправка измениения в систему контроля версий)
2) после чего надо чтоб чтот тригернуло дж (выполнения работы)-хуки на гите ...
3)дж должен получи изминения протестить , сравнить , прогнать против них юнит тесты , функционал тесты - проверить что коммит не ломает текущей логики работы , и вообще он справедлив 
4)если чтот пошло не так то сборка должа отмениться и инфа должна прийти розрабу (в данном случаи через слак)/ но дж может выводить инфу и на сам гит 
5)если по тестам всё гуд , то  собирает результаты нашей работы и получаем артифакт (но он не обезаетен , так как может и не быть сборки , тк в результате может получиться по , или докер образ или я просто проверяю код , если код нормальный можно оставть его как есть , может потом на серв его загрузим в том-же самом виде в котором его седал разраб ) НО чаще всего упаковую в архивы чтоб дальше было работать удобно 
6) дальше артефакт отправляем на серв (допустим есть тест сервак и туда если гуд , дж отправляет артефакт , там его разпоковывает , всё что надо установливает , если всё гуд до розраб получает доступ к новому коду (через браузер , если это браузерное по ...) и инфа приходит виде нотификаций самому разрабу 
7) если чтот пошло не так - тесты не прогнались , установка сломалась - инфа идет розрабу в код и дж в идеале откатывает тестовый сервак в момент до установки 

Как работает дж - он каждое изминения проверяет , если всё гуд - соберает , ставит на сервак , если на серве всё гуд то он так и остаеться ЕСЛИ всё плохо , откатывает изминения до момента ДО установки и пишет это розрабу 



---------------------------------------------
Обьяснения связ smc and  CI/CD 

Когда гит пинает дж по изминениям  и когда дж , сам опрашивает наш гит 
*в идеале надо чтоб дж сам лишний трафик не гинерировал и чтоб его пинали по всем изминениям - тоесть в верхней части пнг - минимизация трафика (как только розраб внес изминения , дж сразу узнал и начал сборку НО для этого надо чтоб гитхаб мог достучатся до ДЖ 
есть пару вариков 
1)если есть гитлаб (локальный) и есть локальный дж  - то тут внутри по локалке они договоряться 
2)если есть внешний гитхаб и дж с внешней точки входа(внешний айпи ...) то они тоже между собой договоряться 
3)если репа наход локально , а дж(внешняя система сборок ...) тогда тоже с локалкы можно достучаться до неё 
НО
если дж локальный а всё остальное наход снаружы , то снаружи в наш локал дж достучаться нельзя - наш случай (но у нас дж наход внутри облака гугл (он закрыт))но через гугл можно это реализовать

ПОЭТОМУ мой дж , будет переодически опрашивать гитхаб 
- дж будет генерить мусорный трафик 
- проверяте изминения по рассписанию (чаще чем раз в минуту делать это не можем 
----------------------------------------------------

Пример 

1)розраб вносит изминения в гит (так как мы собераем докер образ то чаше всего будем его изминять )
2)а дж будет раз в 1 мин стучать на гит , если есть изминения то он будет соберать наш докер образ 

1111)вносим изминения в наш docker_build.jenkins - врезультате чего у нас получаеться тригер (он тригерит сборку , действия его опрашиваютсья scm ('*****')- означает спрашивай каждую минуту - это берёться с учебника дж по пайпам (от туда узнаем что есть тригеры по крону му сцм или апстрим (выше стоящ джом тригерит ниже стоящ - выполнить каскад задач (с условнымы переходами , если туда иначе туда )
2)после того как внесли изминения идем в наш дж , дж не знает что я внёз изминения в пайп , потому как мы до данного  этапа запускали его всегда в ручную , поэтому надо ещё раз запуситиь его в ручную 
*после запуска в console output проверяте наши изминения , чекает посследний коммит И теперь дж знает что ему надо опаршивать гит 	
3) теперь надо внести изминения и чекнуть что всё делаеться норм 
4) иду в докер файл 
*есть разные стандарты писания докер-файлов НО всегда стермяться создать миним. кол-во слоев по суть все раны надо обьяденить в один , тут важен один момент , если я собераю докер образ на одной и тойже машине (у меня дж.масер) то у меня эты слои сохраняются - тоесть те слои что не тронуты сверху (они не проверяются ) пока не доходит на изминения . Тоесть если у меня большой докер-файл который скачивает кучу иструментов розраба и потом запускает дикую компиляцию то нужно думать что обьединять в один слой . Обычно исходный слой кодгда он ставить все необхадимые инстументы - Его учше уне менять 
5) обьединяю строки - && (and ) если первое гуд , то сделай второе* , && \ (екранирование нижней строки) после чего с 2 слоев я делаю один 
* не забудь вкл , авто-обнов стреницы 

Теперь по поводу слоёв - если дж видет что одни и теже слои он их не станет пересобирать (и ты получишь дубликат) , но кода дж видет изминения , он пересоберает заново вышестоящ слой , если я меняю чтот из вышестоящ сточек то пересобераеться вышестоящ слой и изза этого будут вынуждены пересобераться нижестоящ слои 



ВЫВОД

Лучше сделать так чтоб система хранения кода , сама запускала сборки (в случаи гитлаба это удобно так как он сам себе сисд (он умеет не только хранить код но и его соберать ) кароч надо чтоб сист.хран.кода сама запускала джобы - нужно создать линк между ней и сборочным конвеером (в нашем случаи дж), если это не возможно можно сделать то что делал я сегодня  
